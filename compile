#!/usr/bin/env python3
from dataclasses import dataclass
import re


# Define token types and their respective patterns
TOKEN_TYPES = {
    'INTEGER': r'\d+',
    'KEYWORD': r'\b(int|return)\b',  # Recognizes the keywords 'int' and 'return'
    'OPERATOR': r'[\+\-\*/]',
    'EQUALS': r'=',
    'IDENTIFIER': r'[a-zA-Z_][a-zA-Z0-9_]*',
    'LPAREN': r'\(',
    'RPAREN': r'\)',
    'LBRACE': r'\{',  # Recognizes '{'
    'RBRACE': r'\}',  # Recognizes '}'
    'SEMICOLON': r';',  # Recognizes ';'
    'WHITESPACE': r'\s+',  # We will recognize whitespace but won't return it as a token
}



class Offset:
    def __init__(self, value=0):
        self.value = value
    def inc(self, value=1):
        self.value += value
        return self.value
    def __add__(self, other):
        return Offset(self.value + other)
        

# Higher level language constructs will be recognized by a function. Those functions may use other functions to recognize lower level constructs.
# the functions return the number of tokens they consumed, 0 if they didn't recognize anything.
def FUNCTION_DEFINITION(toks):
    o = Offset()
    if toks[o.value][0] != 'KEYWORD' or toks[o.value][1] != 'int' or toks[o.inc()][0] != 'IDENTIFIER' or toks[o.inc()][0] != 'LPAREN': return 0
    args = ARGUMENT_LIST(toks[o.value:])
    if toks[o.inc() + args][0] != 'RPAREN': return 0
    if not (body := BLOCK(toks[o.inc() + args:])): return 0
    return o.value + args + body

def ARGUMENT_LIST(toks):
    offset = 0
    while True:
        if not (arg := DECLARATION(toks[offset:])): return offset
        offset += arg
        if toks[arg][0] != 'COMMA': return offset

def DECLARATION(toks):
    if toks[0][1] != 'int' or toks[1][0] != 'IDENTIFIER': return 0
    return 2

def BLOCK(toks):
    if toks[0][0] != 'LBRACE': return 0
    o = Offset(1)
    while True:
        if not (statement := STATEMENT(toks[o.value:])): return 0
        o += statement
        if toks[o.value][0] == 'RBRACE': return o.inc()

def STATEMENT(toks):
    if toks[0][0] == 'SEMICOLON': return 1
    if (return_statement := RETURN_STATEMENT(toks)) and toks[return_statement][0] == 'SEMICOLON': return return_statement + 1
    if declaration := DECLARATION(toks) and toks[declaration][0] == 'SEMICOLON': return declaration + 1
    if assignment := ASSIGNMENT(toks) and toks[assignment][0] == 'SEMICOLON': return assignment + 1
    if expression := EXPRESSION(toks) and toks[expression][0] == 'SEMICOLON': return expression + 1
    return 0

def RETURN_STATEMENT(toks):
    if toks[0][1] != 'return': return 0
    if expression := EXPRESSION(toks[1:]): return 1 + expression
    return 1

def ASSIGNMENT(toks):
    if toks[0][0] != 'IDENTIFIER' or toks[1][0] != 'EQUALS': return 0
    if expression := EXPRESSION(toks[2:]): return 2 + expression
    return 0

def EXPRESSION(toks):
    if toks[0][0] == "IDENTIFIER" or toks[0][0] == "INTEGER":
        if toks[1][0] != 'OPERATOR': return 1
        if expression := EXPRESSION(toks[2:]): return 2 + expression
        return 0
    if toks[0][0] == 'LPAREN':
        if expression := EXPRESSION(toks[1:]) and toks[1 + expression][0] == 'RPAREN': return 2 + expression
        return 0

@dataclass
class Expression:
    @classmethod
    def parse(cls, toks):
        binary_expression, stop = BinaryExpression.parse(toks)
        if binary_expression: return binary_expression, stop
        unary_expression, stop = UnaryExpression.parse(toks)
        if unary_expression: return unary_expression, stop
        primary_expression, stop = PrimaryExpression.parse(toks)
        if primary_expression: return primary_expression, stop
        if toks[0][0] == 'LPAREN':
            expression, stop = cls.parse(toks[1:])
            if expression and toks[1 + stop][0] == 'RPAREN': return expression, 2 + stop
        return None, 0

@dataclass
class BinaryExpression:
    left: Expression
    operator: str
    right: Expression
    @classmethod
    def parse(cls, toks):
        o = Offset()
        unary_expression, stop = UnaryExpression.parse(toks)
        if not unary_expression:
            primary_expression, stop = PrimaryExpression.parse(toks)
            if not primary_expression: return None, 0
        o += stop
        if toks[o.value][0] != 'OPERATOR': return None, 0
        operator = toks[o.value][1]
        expression, stop = Expression.parse(toks[o.inc():])
        if not expression: return None, 0
        return cls(unary_expression or primary_expression, operator, expression), o.inc() + stop

@dataclass
class UnaryExpression:
    operator: str
    expression: Expression
    @classmethod
    def parse(cls, toks):
        if toks[0][0] != 'OPERATOR': return None, 0
        operator = toks[0][1]
        expression, stop = Expression.parse(toks[1:])
        if not expression: return None, 0
        return cls(operator, expression), 1 + stop

@dataclass
class PrimaryExpression:
    value: str
    @classmethod
    def parse(cls, toks):
        if toks[0][0] == 'IDENTIFIER' or toks[0][0] == 'INTEGER': return cls(toks[0][1]), 1
        return None, 0

@dataclass
class ArgumentList(list):
    @classmethod
    def parse(cls, toks):
        o = Offset()
        args = cls()
        while True:
            arg, stop = Declaration.parse(toks[o.value:])
            if not arg: break
            args.append(arg)
            o += stop
            if toks[o.value][0] != 'COMMA': break
        return args, o.value

@dataclass
class Block(list):
    @classmethod
    def parse(cls, toks):
        if toks[0][0] != 'LBRACE': return None, 0
        o = Offset(1)
        statements = cls()
        while True:
            statement, stop = Statement.parse(toks[o.value:])
            if not statement: break
            statements.append(statement)
            o += stop
            if toks[o.value][0] == 'RBRACE': break
        return statements, o.inc()
        
@dataclass
class FunctionDefinition:
    name: str
    args: ArgumentList
    body: Block
    @classmethod
    def parse(cls, toks):
        o = Offset()
        if toks[o.value][0] != 'KEYWORD' or toks[o.value][1] != 'int': return None, 0
        if toks[o.inc()][0] != 'IDENTIFIER': return None, 0
        name = toks[o.value][1]
        if toks[o.inc()][0] != 'LPAREN': return None, 0
        args, stop = ArgumentList.parse(toks[o.value:])
        o += stop
        if toks[o.inc()][0] != 'RPAREN': return None, 0
        body, stop = Block.parse(toks[o.inc():])
        if not body: return None, 0
        return cls(name, args, body), o.inc() + stop

@dataclass
class Declaration:
    name: str
    @classmethod
    def parse(cls, toks):
        if toks[0][1] != 'int' or toks[1][0] != 'IDENTIFIER': return None, 0
        return cls(toks[1][1]), 2

@dataclass
class Statement:
    @classmethod
    def parse(cls, toks):
        if toks[0][0] == 'SEMICOLON': return cls(), 1
        return_statement, stop = ReturnStatement.parse(toks)
        if return_statement and toks[stop][0] == 'SEMICOLON': return return_statement, stop + 1
        declaration, stop = Declaration.parse(toks)
        if declaration and toks[stop][0] == 'SEMICOLON': return declaration, stop + 1
        assignment, stop = Assignment.parse(toks)
        if assignment and toks[stop][0] == 'SEMICOLON': return assignment, stop + 1
        expression, stop = Expression.parse(toks)
        if expression and toks[stop][0] == 'SEMICOLON': return expression, stop + 1
        return None, 0

@dataclass
class ReturnStatement:
    expression: Expression
    @classmethod
    def parse(cls, toks):
        if toks[0][0] != 'KEYWORD' or toks[0][1] != 'return': return None, 0
        expression, stop = Expression.parse(toks[1:])
        if not expression: return None, 0
        return cls(expression), 1 + stop

@dataclass
class Assignment:
    name: str
    expression: Expression
    @classmethod
    def parse(cls, toks):
        if toks[0][0] != 'IDENTIFIER' or toks[1][0] != 'EQUALS': return None, 0
        expression, stop = Expression.parse(toks[2:])
        if not expression: return None, 0
        return cls(toks[0][1], expression), 2 + stop


    

def lexer(source_code):
    tokens = []
    i = 0
    while i < len(source_code):
        matched = False
        for token_type, pattern in TOKEN_TYPES.items():
            if not (match := re.match(pattern, source_code[i:])): continue
            value = match.group(0)
            if token_type != 'WHITESPACE':  # We skip whitespaces
                tokens.append((token_type, value))
            i += len(value)  # Move the cursor by the matched length
            matched = True
            break  # If we found a match, we break out of the inner loop
        if not matched:
            raise ValueError(f"Unexpected character '{source_code[i]}' at index {i}.")
    return tokens

# Test
source_code = open("hello.c").read()
tokens = lexer(source_code)
print(FUNCTION_DEFINITION(tokens), len(tokens))
print(FunctionDefinition.parse(tokens), len(tokens))
